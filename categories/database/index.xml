<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>database on Bitqiu Blog</title><link>https://blog.bitqiu.cc/categories/database/</link><description>Recent content in database on Bitqiu Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 12 Oct 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.bitqiu.cc/categories/database/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL中EXPLAIN命令详解</title><link>https://blog.bitqiu.cc/p/mysql%E4%B8%ADexplain%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link><pubDate>Sun, 12 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.bitqiu.cc/p/mysql%E4%B8%ADexplain%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid><description>&lt;p>EXPLAIN显示了MySQL如何使用索引来处理SELECT语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。
使用方法，在select语句前加上&lt;code>EXPLAIN&lt;/code>就可以了：&lt;/p>
&lt;p>如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">EXPLAIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">surname&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">first_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FORM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">`=`&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>EXPLAIN&lt;/strong>列的解释：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>列&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>table&lt;/code>&lt;/td>
&lt;td>显示这一行的数据是关于哪张表的。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>type&lt;/code>&lt;/td>
&lt;td>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 &lt;code>const&lt;/code>、&lt;code>eq_reg&lt;/code>、&lt;code>ref&lt;/code>、&lt;code>range&lt;/code>、&lt;code>index&lt;/code>和&lt;code>ALL&lt;/code>。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>possible_keys&lt;/code>&lt;/td>
&lt;td>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从&lt;code>WHERE&lt;/code>语句中选择一个合适的语句。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>key&lt;/code>&lt;/td>
&lt;td>实际使用的索引。如果为&lt;code>NULL&lt;/code>，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在&lt;code>SELECT&lt;/code>语句中使用&lt;code>USE INDEX（indexname）&lt;/code> 来强制使用一个索引或者用&lt;code>IGNORE INDEX（indexname）&lt;/code>来强制MySQL忽略索引。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>key_len&lt;/code>&lt;/td>
&lt;td>使用的索引的长度。在不损失精确性的情况下，长度越短越好。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ref&lt;/code>&lt;/td>
&lt;td>显示索引的哪一列被使用了，如果可能的话，是一个常数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>rows&lt;/code>&lt;/td>
&lt;td>MySQL认为必须检查的用来返回请求数据的行数。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Extra&lt;/code>&lt;/td>
&lt;td>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是&lt;code>Using temporary&lt;/code>和&lt;code>Using filesort&lt;/code>，意思MySQL根本不能使用索引，结果是检索会很慢。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>extra列返回的描述的意义：&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>值&lt;/th>
&lt;th>意义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Distinct&lt;/code>&lt;/td>
&lt;td>一旦MySQL找到了与行相联合匹配的行，就不再搜索了。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Not exists&lt;/code>&lt;/td>
&lt;td>MySQL优化了&lt;code>LEFT JOIN&lt;/code>，一旦它找到了匹配&lt;code>LEFT JOIN&lt;/code>标准的行，就不再搜索了。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Range checked for each Record（index map:#）&lt;/code>&lt;/td>
&lt;td>没有找到理想的索引，因此对于从前面表中来的每一个行组合，MySQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Using filesort&lt;/code>&lt;/td>
&lt;td>看到这个的时候，查询就需要优化了。MySQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Using index&lt;/code>&lt;/td>
&lt;td>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Using temporary&lt;/code>&lt;/td>
&lt;td>看到这个的时候，查询需要优化了。这里，MySQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行&lt;code>ORDER BY&lt;/code>上，而不是&lt;code>GROUP BY&lt;/code>上。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Where used&lt;/code>&lt;/td>
&lt;td>使用了&lt;code>WHERE&lt;/code>从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型&lt;code>ALL&lt;/code>或&lt;code>index&lt;/code>，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>system&lt;/code>&lt;/td>
&lt;td>表只有一行 &lt;code>system&lt;/code> 表。这是const连接类型的特殊情况 。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>const&lt;/code>&lt;/td>
&lt;td>表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MySQL先读这个值然后把它当做常数来对待。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>eq_ref&lt;/code>&lt;/td>
&lt;td>在连接中，MySQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ref&lt;/code>&lt;/td>
&lt;td>这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>range&lt;/code>&lt;/td>
&lt;td>这个连接类型使用索引返回一个范围中的行，比如使用&amp;gt;或&amp;lt;查找东西时发生的情况。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>index&lt;/code>&lt;/td>
&lt;td>这个连接类型对前面的表中的每一个记录联合进行完全扫描（比&lt;code>ALL&lt;/code>更好，因为索引一般小于表数据）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ALL&lt;/code>&lt;/td>
&lt;td>这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>MySQL性能优化小结</title><link>https://blog.bitqiu.cc/p/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</link><pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate><guid>https://blog.bitqiu.cc/p/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</guid><description>&lt;h1 id="一数据库设计和查询优化">一.数据库设计和查询优化&lt;/h1>
&lt;ol>
&lt;li>Schema设计时主要考虑:标准化,数据类型,索引.
&lt;ul>
&lt;li>一个数据库设计可以混合使用,一部分表格标准化,一部分表格非标准化.(非标准化表格适当冗余)&lt;/li>
&lt;li>最优的数据类型,使表在磁盘上占据的空间尽可能小,读写快,占用内存少.(索引也尽量建立在较小的列上)&lt;/li>
&lt;li>正确索引,提高Select,Update,Delete性能.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不同的Sql不同的优化方案
&lt;ul>
&lt;li>Explain Sql查看结果,分析查询.&lt;/li>
&lt;li>查询使用匹配的类型.&lt;/li>
&lt;li>使用long-slow-queries记录较慢查询,分析优化.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h1 id="二服务器端优化">二.服务器端优化&lt;/h1>
&lt;ol>
&lt;li>安装适当的MySql版本.
如果服务器使用Intel处理器,使用Intel C++版本可提高30 %效率&lt;/li>
&lt;li>配置优化.
常见优化项:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>charset&lt;/code>&lt;/li>
&lt;li>&lt;code>max_allowed_packet&lt;/code>&lt;/li>
&lt;li>&lt;code>max_connections&lt;/code>&lt;/li>
&lt;li>&lt;code>table_cache_size&lt;/code>&lt;/li>
&lt;li>&lt;code>query_cache_size&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>三.存储引擎优化&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MyISAM&lt;/strong>
&lt;ol>
&lt;li>引擎特点
&lt;ul>
&lt;li>不支持事务,提供高速存储,检索以及全文搜索能力.&lt;/li>
&lt;li>宕机会破坏表.&lt;/li>
&lt;li>使用的磁盘和内存空间小.&lt;/li>
&lt;li>基于表的锁,并发更新数据会出现严重性能问题.&lt;/li>
&lt;li>MySql只缓存索引,数据由OS缓存.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用情况
&lt;ul>
&lt;li>日志系统.&lt;/li>
&lt;li>只读操作或者大部分读操作.&lt;/li>
&lt;li>全表扫描.&lt;/li>
&lt;li>批量导入数据.&lt;/li>
&lt;li>没有事务的低并发读写.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化策略
&lt;ul>
&lt;li>NOT NULL,可以减少磁盘存储.&lt;/li>
&lt;li>Optimize Table,碎片整理,回收空闲空间.&lt;/li>
&lt;li>Deleting/updating/adding大量数据的时候禁止使用index.&lt;/li>
&lt;li>参数优化,key_buffer_size_variable索引缓存设置.&lt;/li>
&lt;li>避免并发Inset Update.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>InnoDB&lt;/strong>
&lt;ol>
&lt;li>引擎特点
&lt;ul>
&lt;li>具有提交,回滚和崩溃恢复能力的事务安全存储引擎.&lt;/li>
&lt;li>处理巨大数据量性能卓越,它的CPU使用效率非常高.&lt;/li>
&lt;li>需要更多的内存和磁盘存储空间.&lt;/li>
&lt;li>数据和索引都缓存在内存中.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>适用情况
&lt;ul>
&lt;li>需要事务的应用.&lt;/li>
&lt;li>高并发的应用.&lt;/li>
&lt;li>自动恢复.&lt;/li>
&lt;li>较快速的基于主键的操作.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化策略
&lt;ul>
&lt;li>尽量使用short,integer的主键.&lt;/li>
&lt;li>使用prefix keys,因为InnoDB没有key压缩功能.&lt;/li>
&lt;li>参数优化,innodb_buffer_pool_size,innodb_data_home_dir等等.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="三-缓存优化">三. 缓存优化&lt;/h1>
&lt;ol>
&lt;li>Memcached&lt;/li>
&lt;li>Redis&lt;/li>
&lt;/ol>
&lt;p>转自： &lt;a class="link" href="http://allensuiverson.blog.163.com/blog/static/133648269201310119491437/" target="_blank" rel="noopener"
>http://allensuiverson.blog.163.com/blog/static/133648269201310119491437/&lt;/a>&lt;/p></description></item></channel></rss>