[{"content":"goctl 安装 1 2 3 4 5 # Go 1.15 及之前版本 GO111MODULE=on GOPROXY=https://goproxy.cn/,direct go get -u github.com/zeromicro/go-zero/tools/goctl # Go 1.16 及以后版本 GOPROXY=https://goproxy.cn/,direct go install github.com/zeromicro/go-zero/tools/goctl@latest protoc \u0026amp; protoc-gen-go 安装 protoc 是一款用 C++ 编写的工具，其可以将 proto 文件翻译为指定语言的代码。在 go-zer o的微服务中，我们采用 grpc 进行服务间的通信，而 grpc 的编写就需要用到 protoc 和翻译成 go 语言 rpc stub 代码的插件 protoc-gen-go。\n这里使用 goctl 一键安装 1 goctl env check -i -f --verbose ","date":"2022-08-31T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/1.go-zero-%E5%AE%89%E8%A3%85/","title":"1.go-zero 安装"},{"content":"配置要求 2核4G 的服务器 Cent OS 7.8 修改 hostname 1 2 3 4 5 6 7 8 9 10 11 # 修改 hostname hostnamectl set-hostname kubernetes # 查看修改结果 hostnamectl status # 设置 hostname 解析 echo \u0026#34;127.0.0.1 $(hostname)\u0026#34; \u0026gt;\u0026gt; /etc/hosts # 此处 hostname 的输出将会是该机器在 Kubernetes 集群中的节点名字 # 不能使用 localhost 作为节点的名字 cat /etc/redhat-release hostname 检查网络 在所有节点执行命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@k8s-master ~]# ip route show default via 10.1.2.2 dev ens33 proto static metric 100 10.1.2.0/24 dev ens33 proto kernel scope link src 10.1.2.100 metric 100 [root@k8s-master ~]# ip address 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:2e:35:42 brd ff:ff:ff:ff:ff:ff inet 10.1.2.100/24 brd 10.1.2.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::a3e8:7936:50da:d341/64 scope link noprefixroute valid_lft forever preferred_lft forever kubelet使用的IP地址\nip route show 命令中，可以知道机器的默认网卡，通常是 eth0，如 default via 10.1.2.2 dev eth0 ip address 命令中，可显示默认网卡的 IP 地址，Kubernetes 将使用此 IP 地址与集群内的其他节点通信，如 10.1.2.100 所有节点上 Kubernetes 所使用的 IP 地址必须可以互通（无需 NAT 映射、无安全组或防火墙隔离） 安装 containerd / kubelet / kubeadm / kubectl 使用 root 身份在所有节点执行如下代码，以安装软件：\ncontainerd nfs-utils kubectl / kubeadm / kubelet 手动执行以下代码，结果与快速安装相同。请将脚本第79行（已高亮）的 ${1} 替换成您需要的版本号，例如 1.17.4\ndocker hub 镜像请根据自己网络的情况任选一个\n第四行为腾讯云 docker hub 镜像 第六行为DaoCloud docker hub 镜像 第八行为阿里云 docker hub 镜像 1 2 3 4 5 6 7 8 # 在 master 节点和 worker 节点都要执行 # 最后一个参数 1.20.1 用于指定 kubenetes 版本，支持所有 1.20.x 版本的安装 # 腾讯云 docker hub 镜像 # export REGISTRY_MIRROR=\u0026#34;https://mirror.ccs.tencentyun.com\u0026#34; # DaoCloud 镜像 # export REGISTRY_MIRROR=\u0026#34;http://f1361db2.m.daocloud.io\u0026#34; # 阿里云 docker hub 镜像 export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com 在 master 节点和 worker 节点都要执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #!/bin/bash # 在 master 节点和 worker 节点都要执行 # 安装 containerd # 参考文档如下 # https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd cat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/containerd.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # Setup required sysctl params, these persist across reboots. cat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-ip6tables = 1 EOF # Apply sysctl params without reboot sysctl --system # 卸载旧版本 yum remove -y containerd.io # 设置 yum repository yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 安装 containerd yum install -y containerd.io-1.4.3 mkdir -p /etc/containerd containerd config default \u0026gt; /etc/containerd/config.toml sed -i \u0026#34;s#k8s.gcr.io#registry.aliyuncs.com/k8sxio#g\u0026#34; /etc/containerd/config.toml sed -i \u0026#39;/containerd.runtimes.runc.options/a\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ SystemdCgroup = true\u0026#39; /etc/containerd/config.toml sed -i \u0026#34;s#https://registry-1.docker.io#${REGISTRY_MIRROR}#g\u0026#34; /etc/containerd/config.toml systemctl daemon-reload systemctl enable containerd systemctl restart containerd # 安装 nfs-utils # 必须先安装 nfs-utils 才能挂载 nfs 网络存储 yum install -y nfs-utils yum install -y wget # 关闭 防火墙 systemctl stop firewalld systemctl disable firewalld # 关闭 SeLinux setenforce 0 sed -i \u0026#34;s/SELINUX=enforcing/SELINUX=disabled/g\u0026#34; /etc/selinux/config # 关闭 swap swapoff -a yes | cp /etc/fstab /etc/fstab_bak cat /etc/fstab_bak |grep -v swap \u0026gt; /etc/fstab # 配置K8S的yum源 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF # 卸载旧版本 yum remove -y kubelet kubeadm kubectl # 安装kubelet、kubeadm、kubectl # 将 ${1} 替换为 kubernetes 版本号，例如 1.20.1 yum install -y kubelet-${1} kubeadm-${1} kubectl-${1} crictl config runtime-endpoint /run/containerd/containerd.sock # 重启 docker，并启动 kubelet systemctl daemon-reload systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet containerd --version kubelet --version 初始化 master 节点 1 2 3 4 5 6 7 8 9 # 只在 master 节点执行 # 替换 x.x.x.x 为 master 节点的内网IP # export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令 export MASTER_IP=x.x.x.x # 替换 apiserver.demo 为 您想要的 dnsName export APISERVER_NAME=apiserver.demo # Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中 export POD_SUBNET=10.100.0.1/16 echo \u0026#34;${MASTER_IP} ${APISERVER_NAME}\u0026#34; \u0026gt;\u0026gt; /etc/hosts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #!/bin/bash # 只在 master 节点执行 # 脚本出错时终止执行 set -e if [ ${#POD_SUBNET} -eq 0 ] || [ ${#APISERVER_NAME} -eq 0 ]; then echo -e \u0026#34;\\033[31;1m请确保您已经设置了环境变量 POD_SUBNET 和 APISERVER_NAME \\033[0m\u0026#34; echo 当前POD_SUBNET=$POD_SUBNET echo 当前APISERVER_NAME=$APISERVER_NAME exit 1 fi # 查看完整配置选项 https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2 rm -f ./kubeadm-config.yaml cat \u0026lt;\u0026lt;EOF \u0026gt; ./kubeadm-config.yaml --- apiVersion: kubeadm.k8s.io/v1beta2 kind: ClusterConfiguration kubernetesVersion: v${1} imageRepository: registry.aliyuncs.com/k8sxio controlPlaneEndpoint: \u0026#34;${APISERVER_NAME}:6443\u0026#34; networking: serviceSubnet: \u0026#34;10.96.0.0/16\u0026#34; podSubnet: \u0026#34;${POD_SUBNET}\u0026#34; dnsDomain: \u0026#34;cluster.local\u0026#34; --- apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration cgroupDriver: systemd EOF # kubeadm init # 根据您服务器网速的情况，您需要等候 3 - 10 分钟 echo \u0026#34;\u0026#34; echo \u0026#34;抓取镜像，请稍候...\u0026#34; kubeadm config images pull --config=kubeadm-config.yaml echo \u0026#34;\u0026#34; echo \u0026#34;初始化 Master 节点\u0026#34; kubeadm init --config=kubeadm-config.yaml --upload-certs # 配置 kubectl rm -rf /root/.kube/ mkdir /root/.kube/ cp -i /etc/kubernetes/admin.conf /root/.kube/config # 安装 calico 网络插件 # 参考文档 https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises echo \u0026#34;\u0026#34; echo \u0026#34;安装calico-3.17.1\u0026#34; rm -f calico-3.17.1.yaml kubectl create -f https://kuboard.cn/install-script/v1.20.x/calico-operator.yaml wget https://kuboard.cn/install-script/v1.20.x/calico-custom-resources.yaml sed -i \u0026#34;s#192.168.0.0/16#${POD_SUBNET}#\u0026#34; calico-custom-resources.yaml kubectl create -f calico-custom-resources.yaml 检查 master 初始化结果\n1 2 3 4 5 6 7 # 只在 master 节点执行 # 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态 watch kubectl get pod -n kube-system -o wide # 查看 master 节点初始化结果 kubectl get nodes -o wide 初始化 worker节点 获得 join命令参数 在 master 节点上执行\n1 kubeadm token create --print-join-command 可获取kubeadm join 命令及参数，如下所示\n1 2 # kubeadm token create 命令的输出 kubeadm join apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303 初始化worker 针对所有的 worker 节点执行\n1 2 3 4 5 6 7 8 9 10 # 只在 worker 节点执行 # 替换 x.x.x.x 为 master 节点的内网 IP export MASTER_IP=x.x.x.x # 替换 apiserver.demo 为初始化 master 节点时所使用的 APISERVER_NAME export APISERVER_NAME=apiserver.demo echo \u0026#34;${MASTER_IP} ${APISERVER_NAME}\u0026#34; \u0026gt;\u0026gt; /etc/hosts # 替换为 master 节点上 kubeadm token create 命令的输出 kubeadm join apiserver.demo:6443 --token mpfjma.4vjjg8flqihor4vt --discovery-token-ca-cert-hash sha256:6f7a8e40a810323672de5eee6f4d19aa2dbdb38411845a1bf5dd63485c43d303 检查初始化结果 在 master 节点上执行\n1 kubectl get nodes -o wide 输出结果如下所示：\n1 2 3 4 [root@k8s-master ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master Ready master 3m46s v1.17.4 k8s-node Ready \u0026lt;none\u0026gt; 2m20s v1.17.4 ","date":"2021-03-16T11:18:20Z","permalink":"https://blog.bitqiu.cc/p/%E4%BD%BF%E7%94%A8-kubeadm-%E5%AE%89%E8%A3%85-kubernetes/","title":"使用 kubeadm 安装 kubernetes"},{"content":"配置服务 添加 Service\n1 2 3 4 curl -i -X POST \\ --url http://localhost:8001/services/ \\ --data \u0026#39;name=api-gateway-sv\u0026#39; \\ --data \u0026#39;url=https://blog.bitqiu.cc\u0026#39; 为服务添加路由\n1 2 3 curl -i -X POST \\ --url http://localhost:8001/services/api-gateway-sv/routes \\ --data \u0026#39;hosts[]=api.bitqiu.cc\u0026#39; 通过Kong转发您的请求\n1 2 3 curl -i -X GET \\ --url http://localhost:8000/ \\ --header \u0026#39;Host: api.bitqiu.cc\u0026#39; 配置 JWT service 开启 jwt 插件\n1 2 3 4 5 6 7 # 查看插件列表 curl -i -X GET \\ --url http://localhost:8000/ # 开启 jwt 插件 curl -i -X POST \\ --url http://localhost:8001/services/api-gateway-sv/plugins \\ --data \u0026#39;name=jwt\u0026#39; 创建 consumer\n1 2 3 curl -i -X POST \\ --url http://localhost:8000/consumers \\ --data \u0026#39;username=bitqiu\u0026#39; 创建 jwt 凭证\n可以指定算法algorithm，iss签发者key，密钥secret，也可以省略，会自动生成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 curl -i -X POST \\ --url http://localhost:8000/consumers/bitqiu/jwt \\ --data \u0026#39;algorithm=HS256\u0026#39; \\ --data \u0026#39;key=bitqiu_key\u0026#39; \\ --data \u0026#39;secret=uFLMFeKPPL525ppKrqmUiT2rlvkpLc9u\u0026#39; # 查看 jwt 凭证 curl -i -X GET \\ --url http://localhost:8000/consumers/bitqiu/jwt # response { \u0026#34;rsa_public_key\u0026#34;: null, \u0026#34;created_at\u0026#34;: 1553681782, \u0026#34;consumer\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;2e34d380-ec48-4a0d-926f-6dd8696a7eca\u0026#34; }, \u0026#34;id\u0026#34;: \u0026#34;61ee520c-3387-42f0-8e5f-02e0dc34d3d4\u0026#34;, \u0026#34;algorithm\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;secret\u0026#34;: \u0026#34;uFLMFeKPPL525ppKrqmUiT2rlvkpLc9u\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;7Xc3L8TdFpU6kgPEeR4iqMAstqLewJSS\u0026#34; } jwt 下发 业务服务器根据 kong 生成的 jwt 凭证中的 algorithm、key（iss）、secret进行 token 的演算和下发。请求鉴权接口需携带 Authorization: Bearer jwt 进行请求。测试的话可以用 https://jwt.io 生成：\n1 2 3 4 curl -i -X GET \\ --url http://localhost:8000/ \\ --header \u0026#39;Host: api.bitqiu.cc\u0026#39; --header \u0026#39;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkb3dudG93bl9rZXkiLCJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.nDvZa6Nu9cLxO36jnXsHwYIxrNLrDomJgvKJ5gihn4k\u0026#39; ","date":"2020-03-23T11:02:02Z","permalink":"https://blog.bitqiu.cc/p/kong--jwt/","title":"Kong + JWT"},{"content":"有没有发现有时候你会有依赖关系查询的需求，比如：评论大于5的所有文章，那么评论是文章的关系，所以这种我们称为依赖关系查询， 下面举例一个：\n查出所有包含了[laravel]这个标签的所有文章 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php // Post model class Post extends Eloquent { public function tags() { return $this-\u0026gt;belongsToMany(\u0026#39;Tag\u0026#39;); } } // Tag model class Tag extends Eloquent() { public function posts() { return $this-\u0026gt;belongsToMany(\u0026#39;Post\u0026#39;); } } // 查询自上周发布以来包含了 `laravel` 标签的所有文章 $posts = Post::whereHas(\u0026#39;tags\u0026#39;, function($query) { $query-\u0026gt;where(\u0026#39;name\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;laravel\u0026#39;); })-\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39; \u0026gt;= \u0026#39;, Carbon\\Carbon::now()-\u0026gt;subWeek())-\u0026gt;get(); ","date":"2015-09-05T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/laravel-%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2/","title":"laravel 使用依赖关系查询"},{"content":"解决什么问题？ 我们在用着 4.2，过了一段时间作者发布了 5.0，项目可能还没开发完，然后你又像我一样是一个不升级不舒服斯基，那么用升到最新版是你接下来要忙碌的事情。因为你不知道 4.2 ~ 5.0 变化了多少。所以你不可能手动一个个加上或者删除、修改。有的人可能是备份，然后用新版建立一个项目：composer create-project laravel/laravel ，然后把原来自己的代码考过来，然而，变化不一定只是文件新增或者删除啊，可能是原来文件里改了一行，你却没法知道。所以这就头疼了。那么下面我就分享一个超简单的办法来解决这个问题：\n首先我们使用的是 git，如果你不熟悉它的话，起码你这时候应该去补补基本命令了。\n这里假设我们的项目叫做 blog, 然后我们第一步要做的事情是添加官方git源:\n1 2 cd blog # 切到项目根目录 git remote add laravel https://github.com/laravel/laravel # 添加一个源 这里解释一下：\n因为我们的项目基本都已经有一个源origin，就是我们项目用于上传到公司 gitlab 或者 bitbucket 这样的网站用于项目代码管理的地方，所以我们不能破坏它。然后我们添加了一个叫做 laravel，这样就会有两个源了，意味着我们就可以从两个源同步代码。\n拉取 Larvel 的新版代码 拉取指定的 Laravel 分支 注意：在我们拉取 Laravel 源的代码前，请确认你的修改都已经保存并 commit。\n1 git pull laravel master 这里我们从 laravel 的源拉取 master 分支，当然你也可以拉取其它分支的代码。\n合并冲突 拉取完代码，这时候通常是会冲突的，因为你的代码与官方的代码不一样了，冲突部分就是不相同的地方，那么你根据合并结果找到CONFLICT (content): Merge conflict in xxxx.xxx 部分的文件打开，找到冲突的地方合并就好了。\n解决完冲突你的代码结构就与官方一致了，而且这种合并方式不会让你落下任何一个不同的地方。\n当然以上的方法适用于任何 git 管理的项目。比如工作中，你 fork 了主项目，要经常同步主项目的更新时就用这个方法最简单了。\n","date":"2015-06-09T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/%E8%AE%A9%E4%BD%A0%E7%9A%84-laravel-%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%98%E6%96%B9%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5/","title":"让你的 Laravel 应用与官方保持同步"},{"content":"PHPCS 安装 有以下方式安装 PHPCS:\n使用 composer: 1 composer global require \u0026#34;squizlabs/php_codesniffer=*\u0026#34; 注意，你可能需要将 ~/.composer/vendor/bin/ 添加到 PATH 环境变量中，否则会报命令找不到。\n使用 PEAR: 1 pear install PHP_CodeSniffer 下载安装： 1 2 3 4 curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcs.phar php phpcs.phar -h curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar php phpcbf.phar -h 然后移动到命令目录：\n1 2 3 4 5 mv phpcs.phar /usr/bin/phpcs mv phpcbf.phar /usr/bin/phpcbf // 也许上面需要 sudo chmod +x /usr/bin/phpcs chmod +x /usr/bin/phpcbf 这里的 phpcbf 是代码修复工具。\n使用 查看帮助： 1 phpcs --help 添加标准： 1 phpcs --config-set installed_paths PATH_TO_SEARCH_STANDARDS 注意：假设标准为 Weibo, 目录为:\n1 /Users/overtrue/code_standards/Weibo 其中Weibo 里才是 ruleset.xml，那么对应上面的 PATH_TO_SEARCH_STANDARDS 应该为：\n1 phpcs --config-set installed_paths /Users/overtrue/code_standards 查看已经安装的标准： 1 phpcs -i 查看配置： 1 phpcs --config-show 检查代码规范： 1 2 3 phpcs ./codes/Example.php // or phpcs ./codes/ 指定标准：\n1 phpcs ./codes/Example.php --standard=PSR2 报告格式：\n1 phpcs --report=summary /path/to/code 可用的格式有（默认为: full）：\n1 2 3 full, xml, checkstyle, csv json, emacs, source, summary, diff svnblame, gitblame, hgblame or notifysend 修复代码 第一种：使用 diff 形式打补丁：\n1 2 3 phpcs --report-diff=/path/to/changes.diff /path/to/code patch -p0 -ui /path/to/changes.diff # patching file /path/to/code/file.php 第二种：使用 PHP Code Beautifier 和 Fixer：\n1 phpcbf /path/to/code 以上命令会自动修复原文件，如果不想直接覆盖原文件，可以使用 --suffix 指定修复后的代码后缀：\n1 phpcs /path/to/code --suffix=.fixed 更多 PHPCS 的使用请参考：https://github.com/squizlabs/PHP_CodeSniffer/wiki\nPHPMD 安装 同样有以下安装方式：\n下载 phar 文件安装： 1 2 3 wget -c http://static.phpmd.org/php/latest/phpmd.phar mv phpmd.phar /usr/bin/phpmd chmod +x /usr/bin/phpmd 使用 Composer 安装： 1 composer global require phpmd/phpmd 使用 检查代码质量： 1 2 # phpmd 代码路径 报告格式 phpmd /path/to/source text 或者指定要检查的规则：\n1 2 # phpmd 代码路径 报告格式 规则列表 phpmd /path/to/source text codesize,unusedcode,naming 或者使用xml指定检查规则：\n1 2 # phpmd 代码路径 报告格式 规则xml文件 phpmd /path/to/source text /phpmd_ruleset.xml 报告格式有： xml, 以 XML 格式输出； text, 简单的文本格式； html, 输出到单个的html； 这里有一个phpmd规则可参考：https://github.com/overtrue/phpmd-rulesets\n更多关于 PHPMD 的使用请参考：http://phpmd.org/documentation/index.html\n","date":"2015-05-18T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/php%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7phpcsphpmd%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"PHP代码规范与质量检查工具PHPCS,PHPMD的安装与配置"},{"content":"虽然在 /etc/profile 中加了全局 PATH，但是在以 sudo -Hu [username] [command] 执行的时候报命令不存在，原因是 /etc/sudoers 中还有一个 secure_path 没修改：\n1 visudo 查找 secure_path，加入你要添加的目录，比如 /usr/local/bin:\n1 Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin 改为：\n1 Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin 即可。\n","date":"2015-05-08T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/sudo-hu-%E6%89%A7%E8%A1%8C%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","title":"sudo -Hu 执行时找不到命令的问题解决"},{"content":"Laravel 提供了很多默认事件，登录登出、数据库连接与查询、应用启动前后、缓存等等很多默认事件，本篇以用户登录事件来演示如何处理 Larvel 5 的默认事件。 我们的目的：处理用户登录事件，在用户登录的时候给用户添加最后登录时间(last_login_at)，以及最后登录的IP(last_ip)\n用户的登录事件在 Laravel 5 里的事件名称是 auth.login。\n第一步：创建事件处理器 Laravel 5 里直接使用命令即可创建一个事件处理器:\n1 php artisan handler:event AuthLoginEventHandler AuthLoginEventHandler 是我们定义的名称，你可以随意命名(合理的)，它会创建 app/Handlers/Events/AuthLoginEventHandler.php:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php namespace App\\Handlers\\Events; use Illuminate\\Contracts\\Queue\\ShouldBeQueued; use Illuminate\\Queue\\InteractsWithQueue; class AuthLoginEventHandler { /** * Create the event handler. * * @return void */ public function __construct() { // } /** * Handle the event. * * @param Events $event * @return void */ public function handle(Event $event) { // } } 第二步：注册监听 打开 app/Providers/EventServiceProvider.php，将我们的监听添加上:\n1 2 3 4 5 protected $listen = [ \u0026#39;auth.login\u0026#39; =\u0026gt; [ \u0026#39;App\\Handlers\\Events\\AuthLoginEventHandler\u0026#39;, ], ]; 第三步：添加逻辑代码 我们的需求是：在用户登录的时候给用户添加最后登录时间(last_login_at)，以及最后登录的IP(last_ip)。\n注意：这两个字段是我自己创建的 当然，这里只是举例，你可以在这里完成所有你想要的需求。\n注意：框架默认的事件触发时的参数都可能不同，具体请查看框架源码或者参阅相关文档。 小窍门：使用 关键字 fire(' 在框架目录中搜索，可以得到大部分的框架事件的调用处。\n这里 auth.login 事件框架会传递两个参数：用户实例, 是否记住登录，所以我们修改我们刚刚创建的 AuthLoginEventHandler.php 中的 handle 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 处理用户登录 * * @param User $user 用户 * @param boolean $remember 是否记住登录 * * @return void */ public function handle(User $user, $remember) { $user-\u0026gt;last_login_at = Carbon::now(); $user-\u0026gt;last_ip = $this-\u0026gt;request-\u0026gt;ip(); //TODO:其它动作，比如增加积分等等。 $user-\u0026gt;save(); } 可以看到上面我们用到了 Illuminate\\Http\\Request 对象，所以我们还需要添加一个属性 protected $request，然后从构造方法 __construct 让框架注入进来（由框架完成注入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... /** * Request 对象 * * @var Illuminate\\Http\\Request */ protected $request; /** * Create the event handler. * * @return void */ public function __construct(Request $request) { $this-\u0026gt;request = $request; } ... 我们所有用到的类请记得引入。最后完整的 AuthLoginEventHandler.php 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?php namespace App\\Handlers\\Events; use Illuminate\\Contracts\\Queue\\ShouldBeQueued; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Http\\Request; use App\\Models\\User; use Carbon\\Carbon; class AuthLoginEventHandler { /** * Request 对象 * * @var Illuminate\\Http\\Request */ protected $request; /** * Create the event handler. * * @return void */ public function __construct(Request $request) { $this-\u0026gt;request = $request; } /** * 处理用户登录 * * @param User $user 用户 * @param boolean $remember 是否记住登录 * * @return void */ public function handle(User $user, $remember) { $user-\u0026gt;last_login_at = Carbon::now(); $user-\u0026gt;last_ip = $this-\u0026gt;request-\u0026gt;ip(); //TODO:其它动作，比如增加积分等等。 $user-\u0026gt;save(); } } 然后在用户登录的时候就会自动给用户字段 last_login_at 和 last_ip 补充内容了。是不是很方便呢？\n","date":"2015-04-17T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/%E5%A4%84%E7%90%86-laravel-5-%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/","title":"处理 Laravel 5 默认事件"},{"content":"我们有时候需要获取当前 Laravel 项目的控制器或者方法名，框架默认是不会提供单独的方法的，框架只提供了如下的方法：\n1 \\Route::current()-\u0026gt;getActionName(); 返回的结果是：\n1 App\\Http\\Controllers\\WelcomeController@index 可是这不是我们想要的，我们只想获取控制器名或者方法名，那么，你可以自定义下面三个函数来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 获取当前控制器名 * * @return string */ public function getCurrentControllerName() { return getCurrentAction()[\u0026#39;controller\u0026#39;]; } /** * 获取当前方法名 * * @return string */ public function getCurrentMethodName() { return getCurrentAction()[\u0026#39;method\u0026#39;]; } /** * 获取当前控制器与方法 * * @return array */ public function getCurrentAction() { $action = \\Route::current()-\u0026gt;getActionName(); list($class, $method) = explode(\u0026#39;@\u0026#39;, $action); return [\u0026#39;controller\u0026#39; =\u0026gt; $class, \u0026#39;method\u0026#39; =\u0026gt; $method]; } 另外推荐近期完成的两个 Laravel 拓展包：\novertrue/laravel-lang 基于 Laravel4-lang 的 44 语种语言文件 overtrue/laravel-pinyin Laravel 中文转拼音， 基于 overtrue/pinyin ","date":"2015-03-19T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/laravel-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8D%E7%A7%B0%E6%88%96%E6%96%B9%E6%B3%95/","title":"Laravel 获取当前控制器名称或方法"},{"content":"当我们在存储mongo数据的时候，整型字段存储的值为NumberLong格式，那么如果这个id来自于MySQL，在使用MySQL模型与MongoDB关联查询时就会踩到这个坑，从jenssegers/laravel-mongodb生成的SQL可以看到类似这样的结果：\n1 ...{\u0026#34;object_id\u0026#34;:{\u0026#34;$in\u0026#34;:[\u0026#34;13\u0026#34;, \u0026#34;15\u0026#34;]}}... 可是我们的期望是：\n1 ...{\u0026#34;object_id\u0026#34;:{\u0026#34;$in\u0026#34;:[13, 15]}}... 这里的13、15是MySQL里的一条记录，在mongo里的值为NumberLong(13)， 所以查询结果永远为空。 找遍了源码，没有一个更好的解决方法，后来只能使用Eloquent模型提供的属性修改器来实现：\n在MySQL的模型里对相应字段使用修改器(这里以id为例)：\n1 2 3 4 5 6 7 8 9 10 11 /** * 避免与mongo关联时id转为字符的问题 * * @param string $id * * @return int */ public function getIdAttribute($id) { return intval($id); } 方法名：get属性名大驼峰Attribute, ex: object_id -\u0026gt; getObjectIdAttribute\n框架源码参考：getAttribute\n","date":"2014-12-15T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/laravel%E6%8B%93%E5%B1%95jenssegers/laravel-mongodb%E4%B8%8Emysql%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","title":"Laravel拓展jenssegers/laravel-mongodb与MySQL关联查询字段类型不一致问题解决方案"},{"content":"EXPLAIN显示了MySQL如何使用索引来处理SELECT语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 使用方法，在select语句前加上EXPLAIN就可以了：\n如：\n1 EXPLAIN SELECT `surname`,`first_name` FORM `a`,`b` WHERE `a`.`id`=`b`.`id` EXPLAIN列的解释：\n列 描述 table 显示这一行的数据是关于哪张表的。 type 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 const、eq_reg、ref、range、index和ALL。 possible_keys 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句。 key 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname） 来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引。 key_len 使用的索引的长度。在不损失精确性的情况下，长度越短越好。 ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。 rows MySQL认为必须检查的用来返回请求数据的行数。 Extra 关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。 extra列返回的描述的意义：\n值 意义 Distinct 一旦MySQL找到了与行相联合匹配的行，就不再搜索了。 Not exists MySQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。 Range checked for each Record（index map:#） 没有找到理想的索引，因此对于从前面表中来的每一个行组合，MySQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。 Using filesort 看到这个的时候，查询就需要优化了。MySQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。 Using index 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。 Using temporary 看到这个的时候，查询需要优化了。这里，MySQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。 Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）。 system 表只有一行 system 表。这是const连接类型的特殊情况 。 const 表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MySQL先读这个值然后把它当做常数来对待。 eq_ref 在连接中，MySQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。 ref 这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。 range 这个连接类型使用索引返回一个范围中的行，比如使用\u0026gt;或\u0026lt;查找东西时发生的情况。 index 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。 ALL 这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。 ","date":"2014-10-12T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/mysql%E4%B8%ADexplain%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","title":"MySQL中EXPLAIN命令详解"},{"content":"PHP是弱类型，动态的语言脚本。在申明一个变量的时候，并不需要指明它保存的数据类型。 例如：\n1 2 3 4 5 6 \u0026lt;?php $var = 1; $var = \u0026#34;variable\u0026#34;; $var = 1.00; $var = array(); $var = new Object(); 动态变量，在运行期间是可以改变的，并且在使用前无需声明变量类型。\n问题一、Zend引擎是如何用C实现这种弱类型的呢？\n实际上，在PHP中声明的变量，在ZE中都是用结构体zval来保存的。 首先我们打开Zend/zend.h来看zval的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef struct _zval_struct zval; struct _zval_struct { /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc; }; typedef union _zvalue_value { long lval; /* long value */ double dval; /* double value */ struct { char *val; int len; } str; HashTable *ht; /* hash table value */ zend_object_value obj; } zvalue_value; Zend/zend_types.h：\n1 2 3 4 5 typedef unsigned char zend_bool; typedef unsigned char zend_uchar; typedef unsigned int zend_uint; typedef unsigned long zend_ulong; typedef unsigned short zend_ushort; 从上述代码中，可以看到_zvalue_value是真正保存数据的关键部分。通过共用体实现的弱类型变量声明\n问题二、Zend引擎是如何判别、存储PHP中的多种数据类型的呢？\n_zval_struct.type中存储着一个变量的真正类型，根据type来选择如何获取zvalue_value的值。\ntype值列表(Zend/zend.h)：\n1 2 3 4 5 6 7 8 9 10 #define IS_NULL 0 #define IS_LONG 1 #define IS_DOUBLE 2 #define IS_BOOL 3 #define IS_ARRAY 4 #define IS_OBJECT 5 #define IS_STRING 6 #define IS_RESOURCE 7 #define IS_CONSTANT 8 #define IS_CONSTANT_ARRAY 9 来看一个简单的例子：\n1 2 3 4 5 \u0026lt;?php $a = 1; //此时zval.type = IS_LONG,那么zval.value就去取lval. $a = array(); //此时zval.type = IS_ARRAY,那么zval.value就去取ht. 这其中最复杂的，并且在开发第三方扩展中经常需要用到的是\u0026quot;资源类型\u0026quot;. 在PHP中，任何不属于PHP的内建的变量类型的变量，都会被看作资源来进行保存。 比如：数据库句柄、打开的文件句柄、打开的socket句柄。\n资源类型，会用lval，此时它是一个整型指示器， 然后PHP会再根据这个指示器在PHP内建的一个资源列表中查询相对应的资源。\n正是因为ZE这样的处理方式，使PHP就实现了弱类型，而对于ZE的来说，它所面对的永远都是同一种类型zval。\n转自：http://allensuiverson.blog.163.com/blog/static/13364826920131013103226827/\n","date":"2014-10-12T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/php%E7%9A%84%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0/","title":"PHP的弱类型实现"},{"content":"一.数据库设计和查询优化 Schema设计时主要考虑:标准化,数据类型,索引. 一个数据库设计可以混合使用,一部分表格标准化,一部分表格非标准化.(非标准化表格适当冗余) 最优的数据类型,使表在磁盘上占据的空间尽可能小,读写快,占用内存少.(索引也尽量建立在较小的列上) 正确索引,提高Select,Update,Delete性能. 不同的Sql不同的优化方案 Explain Sql查看结果,分析查询. 查询使用匹配的类型. 使用long-slow-queries记录较慢查询,分析优化. 二.服务器端优化 安装适当的MySql版本. 如果服务器使用Intel处理器,使用Intel C++版本可提高30 %效率 配置优化. 常见优化项: charset max_allowed_packet max_connections table_cache_size query_cache_size 三.存储引擎优化\nMyISAM 引擎特点 不支持事务,提供高速存储,检索以及全文搜索能力. 宕机会破坏表. 使用的磁盘和内存空间小. 基于表的锁,并发更新数据会出现严重性能问题. MySql只缓存索引,数据由OS缓存. 适用情况 日志系统. 只读操作或者大部分读操作. 全表扫描. 批量导入数据. 没有事务的低并发读写. 优化策略 NOT NULL,可以减少磁盘存储. Optimize Table,碎片整理,回收空闲空间. Deleting/updating/adding大量数据的时候禁止使用index. 参数优化,key_buffer_size_variable索引缓存设置. 避免并发Inset Update. InnoDB 引擎特点 具有提交,回滚和崩溃恢复能力的事务安全存储引擎. 处理巨大数据量性能卓越,它的CPU使用效率非常高. 需要更多的内存和磁盘存储空间. 数据和索引都缓存在内存中. 适用情况 需要事务的应用. 高并发的应用. 自动恢复. 较快速的基于主键的操作. 优化策略 尽量使用short,integer的主键. 使用prefix keys,因为InnoDB没有key压缩功能. 参数优化,innodb_buffer_pool_size,innodb_data_home_dir等等. 三. 缓存优化 Memcached Redis 转自： http://allensuiverson.blog.163.com/blog/static/133648269201310119491437/\n","date":"2014-10-01T00:00:00Z","permalink":"https://blog.bitqiu.cc/p/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/","title":"MySQL性能优化小结"}]